### 1. 처음 접하는 jsx
#####  **jsx 문법이란?**
js파일 안에 html을 직관적으로 작성하기 위해 도와주는 react 기본 내장 문법

#### 1-1 class선언
대표적으로 두드러지는 문법은 class인데 react에서는 class라는 키워드를 사용할 수는 없고 대신 `className`이라고 사용해야한다. 
- ex) `className = "black-nav"`

js의 영향을 받아 네이밍 또한 `camelCase`를사용해야한다.


#### 1-2 Data Binding
`Data-Binding`은 Js데이터를 HTML 에 넣는 작업을 뜻한다
Front-ent, Web-App 개발 시 Data-Binding할 작업이 많은데 React에서는 이걸 매우 쉽게 구현 할 수 있다

js의 전통적인 방식인
`document.getElementById().innerHTML = ''`
을 선언하지 않고
대신
ex)
```node.js
function App() {
	let data = '안녕하세요';
	return (
		<div className = "App">
			<div className = "black-nav">
				<div>Blog </div>
				<div> {data} </div>
			</div>
		</div>
	)
}
```
이런식으로 중간에 `{중괄호}`를 사용하면 변수로 선언한 내용을 넣을 수 있다.
`href` ,`id`,`className`,`src` 등 여러가지 `HTML` 속성들에도 `Data-binding`이 가능하다.

`HTML`중`style`속성은 `{속성명: 속성값}`를 사용하여 오브젝트로 바꿔서넣어야 한다.
속성명에 `-`기호를 사용할 수 없다. 대신,`camelCase`로 치환해줘야 한다.

```node.js
<div style = {{ color : 'blue', fontSize : '30px'}}> 글씨 </div> 
```

#### 1-3 useState
`useState`를 사용하기 위해서는 두 줄의 코드가 추가되어야 한다

```node.js
import React, {useState} from 'react';
let [a,b] = useState('동탄 맛집 추천')
```

첫번째 코드는 useState를 import 시키는코드이다.
이게 있어야 useState를 선언할 수 있다.

두번째는 사용예제인데, 자세히 살펴보자 `data`는 `[데이터1, 데이터2]`을 사용한 `array`다.

보통 실제 저장할 데이터와 저장할 데이터를 넣어준다
- 보통은 a위치에는 실제로 저장할 데이터
- b위치에는 저장할 데이터를 변경시킬 함수
##### 1-3-1 useState를 사용하는 이유
다른 변수를 사용하면 변수 안의 값이 바뀌면 보통 새로고침 해야 재렌더링 해야 표기가 되지만

==12-24일==

State를 사용하면 새로고침을 하지 않아도 재렌더링이 가능하다

##### 1-3-2 useState를 사용할 때 let 보다 const를 더 자주 사용하는 이유

const는 보통 상수(변하지 않는 수)를 변수로 지정할 때 자주 사용한다 그러나 useState를 사용할 때는 조금 다르게 적용된다.

만약 const를 사용하게 되면 변수 내용이 바뀌었을 때만 재렌더링 된다

그러나 let을 사용하면 변수 내용이 바뀌지 않았을 때도 계속 렌더링하게 된다.

결론 
- const = **변수 내용이 바뀌었을 때만** 재렌더링
- let = **변수 내용이 바뀌지 않았어도** 재렌더링

#### 1-4 hook


#### 1-5 useEffect
렌더링 될 때마다 특정 작업을 실행할 수 있도록 하는 리액트 Hook이다.
여기서 Side effect는 component가 렌더링 된 이후에 비동기로 처리해야 하는 부수적인 효과를 말한다.

useEffect는 component가 mount 됐을 때, component가 됐을 때, component가 update 됐을 때, 특정 작업을 처리할 수 있다. 


##### 1-5-1 useEffect 사용방법

ex)
`useEffect(function, deps)`
- function  : 수행하고자 하는 작업

- deps : 배열 형태이며, 배열 안에는 검사하고자 하는 특정 값 or 빈 배열

###### 불러오는 법
```jsx
import React, {useEffect} from 'react';
```


##### 1-5-2 useEffect 사용 방식

==1.componentDidMound==
###### Component가 mount 됐을 때(처음 나타났을 때 실행)
```jsx
useEffect(() => {
	console.log('마운트 될 때만 실행된다');
}, []);
```

###### 컴포넌트가 화면에 가장 처음 렌더링 될 때 한번만 실행하고 싶다면 deps 위치에빈 배열을 넣는다.
```jsx
useEffect(() => {
	console.log('렌더링 될 때 마다 실행된다');
});
```

==2.componentDidUpdate==
###### Component가 update 될때(특정 props, state가 바뀔 때 실행)

```jsx
const mounted = useRef(false);
	useEffect(() => {
		if (!mounted.current) {
			mounted.current = true;
		}else{
			console.log(name);
			console.log("업데이트 될 때마다 실행");
		}
	}, [name]);
```

==3.componentDidUnMount==

Component가 unmount 될때 (사라질 때) & update 되기 전에 실행

```jsx
useEffect(() => {
	console.log('effect');
	console.log(name);
	return () =>{
		console.log('cleanup')
		console.log(name);
	}
})
```
==12-25일==

#### 1-6 useContext
출처 : https://velog.io/@jminkyoung/TIL-6-React-Hooks-useContext-%EB%9E%80
useContext는 기존의React에 존재하는 Context를 더 편하게 사용할 수 있게 해주는 역할을 한다

그렇다면 **Context**란 무엇일까?

##### 1-6-1 Context란?
react공식 문서에는 `context 를이용하면 단계마다 일일이 props를 넘겨주지 않고도 컴포넌트 트리전체에 데이터를 제공할 수 있습니다`라고 적혀있다   

>일반적인 React 앱에선느 데이터는 props를 통해서 부모에서 자식에게 전달되지만, 앱 안의 여러 컴포넌트들에게  props를 전달해야 하는 경우 context를 이용하면 명시적으로 props를 넘겨주지 않아도 값을 공유할 수 있게 해주는 것 

>한마디로 **데이터가 필요할때마다 props를 통해 전달할 필요가 없이 context를 이용해 공유한다 **

context API를 사용하기위해서는  Provider, Consumer, createContext 이렇게 세가지의 개념을 알아야 한다
- `createContext`: context 객체 생성
- `Provider` : 생성한 context를 하위 컴포넌트에게 전달하는 역할
- `Consumer` :  context의 변화를 감시하는 컴포넌트 

##### 1-6-2 Context 예제
###### 적용 전
App.js
```jsx
import React, {createContext} from "react";
import Children from "./Children";

export const AppContext = createContext();

const App = () => {
	const user = {
		name : "민채홍"
		job : "학생"
	};
	return (
		<>
			<AppContext.Provider value = {user}>
				<div>
					<Children />
				</div>
			</AppContext.Provider>
		</>
	);
};

export default App;
```

Children.js
```jsx

import React from "react";
import { AppContext } from "./App";

const Children = () => {
  return (
      <AppContext.Consumer>
        {(user) => (
          <>
            <h3>AppContext에 존재하는 값의 name은 {user.name}입니다.</h3>
            <h3>AppContext에 존재하는 값의 job은 {user.job}입니다.</h3>
          </>
        )}
      </AppContext.Consumer>
  );
};

export default Children;
```

![[1.jsx문법이란-20250102181502316.webp]]
이 예제에선 하나의 컴포넌트에서만 context를 사용했지만 코드가 늘어나면 여러 컴포넌트에서 사용이 가능하지만 코드가 점점 더러워지는 문제가 생긴다.

###### 적용 후
```jsx
import React, { useContext } from "react";
import { AppContext } from "./App";

const Children = () => {
  // useContext를 이용해서 따로 불러온다.
  const user = useContext(AppContext);
  return (
    <>
      <h3>AppContext에 존재하는 값의 name은 {user.name}입니다.</h3>
      <h3>AppContext에 존재하는 값의 job은 {user.job}입니다.</h3>
    </>
  );
};

export default Children;
```

App.js에서 Context를 생성하고 Provider를 통해 전달하는 코드는 그대로지만 Children.js에서 `AppContext`를사용하는 과정에서 `<AppContext.Consumer>`같은코드를 사용해서 복잡하게 작성하지 않고 `const user = useContext(AppContext)`를 통해 Context를 불러 온후 바로 사용이 가능하게 바뀌었다.   

==12 - 26==