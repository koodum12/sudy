#designPattern 

 [다른 사람이 쓴 거](https://velog.io/@dolphin-pc/FE-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98)

### MVC 패턴

FE라는 개념이 없던 시절 웹사이트 자체가 View였기에, Model을 통한 View를 그려주는 매우 단순한 방식으로 흘러감

`View` > `Controller` > `Model` > `View` 방식으로 흘러간다.

단점은 매우 명확, `Model과 View이 끈끈하다는 것`
- 대부분 운영환경의 경우, Model보다는 View쪽에서 변경사항이 많이 발생.
- `MVC`경우 `View`의 수정이 필요할 때마다, `Model`의 변경또한 불가피해진다.

##### 요약
> 옛날엔 FE역할 x, 초기엔 Model을 통한 View를 그리는 매우 단순한 방식을 택함

> 단순함 but **MVC간의 결합도가 높음**.
> 1.코드 복잡성이 높음.
> 2.유지보수/테스트가 어려움
> 3.비즈니스 로직의 (관심사)분리가 애매한 상황이 존재할 수 있음.

### MVP 패턴(Model-View-Presenter)

- MVC 패턴의 의존성을 낮추고자 나온 패턴
- Presenter가 Controller의 역할을 대신함 but 흐름의 순서에 차이가 생김
- `View` > `Presenter` > `Model` > `Presenter` > `View`

##### 요약

> MVC패턴에서의 `View-Model`간의 **결합도를 낮춘다**

>Presenter의 역할이 중요해짐, **결합도 또한 증가**


### MVVM 패턴
- `Model-View-ViewModel`로, 이전의 MVP패턴과 달리 \* `데이터 바인딩`이라는 개념으로 결합돋를 조금 더 낮추게 한다.

>**데이터 바인딩**?
> 
>View의 속성과 ViewModel의 속성을 연결하여, 유기적인 관계로 만드는 것
> (ex. 뷰모델의 `userName`속성과 뷰의 `Input의 value` 속성을 바인딩하면, userName이 변경될 때마다 TextInput의 값도 자동으로 변경되는 것이다.)

- 이러한 데이터바인딩을 통해, View와 ViewModel의 연결을 확립하기에는 MVP패턴보다는 결합도가 낮음.

##### 요약

>MVVM은 `데이터바인딩`을 통해 UI와 비즈니스로직을 분리하여, 재사용성과 유지보수성을 높인다.

>ViewModel의 설계가 어려움으로 학습곡석 높음


### Component 패턴

- MVVM패턴에서 더욱 재사용성이 높은 패턴을 찾음 -> 그게 `Component` 패턴
- 하나의 Page안에서 여러 모듈을 조립하는 방식

##### 요약

>재사용성, 모듈화, 독립성 등 컴포넌트 기반으로 한 개발방식
> 비즈니스 로직이 컴포넌트에 포함, 재사용성이 떨어지기에 UI와 비즈니스 로직을 분리하여 `Contailner-Presenter`방식을 초기해는 활용


>컴포넌트 단위로 쪼개다 보니, 컴포넌트간의 유기적인 데이터관리가 어려움.


### Flux 패턴

- **Component패턴**은 props를 통해서만 데이터를 관리하다보니 \*데이터의 파편화가 되어있음.
- 이를 해결하기 위해 store라는 전역저장소를 두어, 단방향적인 데이터흐름인 `Flux패턴`이 탄생

> 데이터 파편화
>
> 하나의 일관된 데이터가 여러 조각으로 분리돼서 흩어져 존재하는 상태.

![[디자인 패턴 종류-20250708110207901.webp]]

- `Action`객체를 Dispatcher함수를 통해 Store에 반영하면, Store를 구독하는 View에 반영되는 흐름.

**Props Drilling 해소**
>전역 상태관리 시대의 시작

**props Drilling이란?**
>상위 컴포넌트의 데이터를 하위 컴포넌트로 전달하기 위해 여러 단계(중간 컴포넌트)를 거쳐 Props로 계속 전달하는 현상.

**높은 러닝커브**
>상태관리만을 위한 코드(보일러 플레이트, Redux)

**러닝 커브란?**
>어떤 기술, 지식, 시스템 등을 익히고 숙련해 가는 데 걸리는 시간과 노력의 양을 시각적으로 표현한 개념
>
>보통
>x축: 시간 or 경험
>y축: 숙련도 또는 생산성

### Observer-Observable 패턴

- 1 : 다 관계의 종속성을 정의하는 패턴

- Flux와 비슷하나, Action과 Dispatch를 배제하여, 변경된 값을 모두에게 전달하는 방식.

### Atomic 패턴
- 지금의 Recoil(React 상태 관리 라이브러리)이 따르고 있는 패턴
- Model이 쉽게 접근하는 방법을 목표로 함

아마 이게 최근에 사용하는 디자인 패턴일꺼임 ㅇㅇ